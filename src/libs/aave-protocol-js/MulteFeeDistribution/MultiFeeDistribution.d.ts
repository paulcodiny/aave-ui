/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from 'ethers';
import { BytesLike } from '@ethersproject/bytes';
import { Listener, Provider } from '@ethersproject/providers';
import { FunctionFragment, EventFragment, Result } from '@ethersproject/abi';
import type { TypedEventFilter, TypedEvent, TypedListener } from './common';

interface MultiFeeDistributionInterface extends ethers.utils.Interface {
  functions: {
    'addReward(address)': FunctionFragment;
    'claimableRewards(address)': FunctionFragment;
    'earnedBalances(address)': FunctionFragment;
    'exit(bool)': FunctionFragment;
    'getReward(address[])': FunctionFragment;
    'getRewardForDuration(address)': FunctionFragment;
    'incentivesController()': FunctionFragment;
    'lastTimeRewardApplicable(address)': FunctionFragment;
    'lockDuration()': FunctionFragment;
    'lockedBalances(address)': FunctionFragment;
    'lockedSupply()': FunctionFragment;
    'mint(address,uint256,bool)': FunctionFragment;
    'minters(address)': FunctionFragment;
    'mintersAreSet()': FunctionFragment;
    'owner()': FunctionFragment;
    'recoverERC20(address,uint256)': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'rewardData(address)': FunctionFragment;
    'rewardPerToken(address)': FunctionFragment;
    'rewardTokens(uint256)': FunctionFragment;
    'rewards(address,address)': FunctionFragment;
    'rewardsDuration()': FunctionFragment;
    'setIncentivesController(address)': FunctionFragment;
    'setMinters(address[])': FunctionFragment;
    'stake(uint256,bool)': FunctionFragment;
    'stakingToken()': FunctionFragment;
    'totalBalance(address)': FunctionFragment; // total staked + locked
    'totalSupply()': FunctionFragment; // Geist staked total
    'transferOwnership(address)': FunctionFragment;
    'unlockedBalance(address)': FunctionFragment;
    'userRewardPerTokenPaid(address,address)': FunctionFragment;
    'withdraw(uint256)': FunctionFragment;
    'withdrawExpiredLocks()': FunctionFragment;
    'withdrawableBalance(address)': FunctionFragment;
  };

  encodeFunctionData(functionFragment: 'addReward', values: [string]): string;
  encodeFunctionData(functionFragment: 'claimableRewards', values: [string]): string;
  encodeFunctionData(functionFragment: 'earnedBalances', values: [string]): string;
  encodeFunctionData(functionFragment: 'exit', values: [boolean]): string;
  encodeFunctionData(functionFragment: 'getReward', values: [string[]]): string;
  encodeFunctionData(functionFragment: 'getRewardForDuration', values: [string]): string;
  encodeFunctionData(functionFragment: 'incentivesController', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lastTimeRewardApplicable', values: [string]): string;
  encodeFunctionData(functionFragment: 'lockDuration', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lockedBalances', values: [string]): string;
  encodeFunctionData(functionFragment: 'lockedSupply', values?: undefined): string;
  encodeFunctionData(functionFragment: 'mint', values: [string, BigNumberish, boolean]): string;
  encodeFunctionData(functionFragment: 'minters', values: [string]): string;
  encodeFunctionData(functionFragment: 'mintersAreSet', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'recoverERC20', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rewardData', values: [string]): string;
  encodeFunctionData(functionFragment: 'rewardPerToken', values: [string]): string;
  encodeFunctionData(functionFragment: 'rewardTokens', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'rewards', values: [string, string]): string;
  encodeFunctionData(functionFragment: 'rewardsDuration', values?: undefined): string;
  encodeFunctionData(functionFragment: 'setIncentivesController', values: [string]): string;
  encodeFunctionData(functionFragment: 'setMinters', values: [string[]]): string;
  encodeFunctionData(functionFragment: 'stake', values: [BigNumberish, boolean]): string;
  encodeFunctionData(functionFragment: 'stakingToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalBalance', values: [string]): string;
  encodeFunctionData(functionFragment: 'totalSupply', values?: undefined): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [string]): string;
  encodeFunctionData(functionFragment: 'unlockedBalance', values: [string]): string;
  encodeFunctionData(functionFragment: 'userRewardPerTokenPaid', values: [string, string]): string;
  encodeFunctionData(functionFragment: 'withdraw', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'withdrawExpiredLocks', values?: undefined): string;
  encodeFunctionData(functionFragment: 'withdrawableBalance', values: [string]): string;

  decodeFunctionResult(functionFragment: 'addReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimableRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'earnedBalances', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReward', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRewardForDuration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'incentivesController', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastTimeRewardApplicable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockDuration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockedBalances', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockedSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'mint', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'minters', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'mintersAreSet', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'recoverERC20', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardPerToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardsDuration', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setIncentivesController', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setMinters', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stake', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stakingToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupply', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unlockedBalance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userRewardPerTokenPaid', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawExpiredLocks', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawableBalance', data: BytesLike): Result;

  events: {
    'OwnershipTransferred(address,address)': EventFragment;
    'Recovered(address,uint256)': EventFragment;
    'RewardAdded(uint256)': EventFragment;
    'RewardPaid(address,address,uint256)': EventFragment;
    'RewardsDurationUpdated(address,uint256)': EventFragment;
    'Staked(address,uint256,bool)': EventFragment;
    'Withdrawn(address,uint256,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Recovered'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardPaid'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardsDurationUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Staked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Withdrawn'): EventFragment;
}

export type OwnershipTransferredEvent = TypedEvent<
  [string, string] & { previousOwner: string; newOwner: string }
>;

export type RecoveredEvent = TypedEvent<[string, BigNumber] & { token: string; amount: BigNumber }>;

export type RewardAddedEvent = TypedEvent<[BigNumber] & { reward: BigNumber }>;

export type RewardPaidEvent = TypedEvent<
  [string, string, BigNumber] & {
    user: string;
    rewardsToken: string;
    reward: BigNumber;
  }
>;

export type RewardsDurationUpdatedEvent = TypedEvent<
  [string, BigNumber] & { token: string; newDuration: BigNumber }
>;

export type StakedEvent = TypedEvent<
  [string, BigNumber, boolean] & {
    user: string;
    amount: BigNumber;
    locked: boolean;
  }
>;

export type WithdrawnEvent = TypedEvent<
  [string, BigNumber, BigNumber] & {
    user: string;
    receivedAmount: BigNumber;
    penaltyPaid: BigNumber;
  }
>;

export class MultiFeeDistribution extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: MultiFeeDistributionInterface;

  functions: {
    addReward(
      _rewardsToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    claimableRewards(
      account: string,
      overrides?: CallOverrides
    ): Promise<
      [([string, BigNumber] & { token: string; amount: BigNumber })[]] & {
        rewards: ([string, BigNumber] & { token: string; amount: BigNumber })[];
      }
    >;

    earnedBalances(
      user: string,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        ([BigNumber, BigNumber] & {
          amount: BigNumber;
          unlockTime: BigNumber;
        })[]
      ] & {
        total: BigNumber;
        earningsData: ([BigNumber, BigNumber] & {
          amount: BigNumber;
          unlockTime: BigNumber;
        })[];
      }
    >;

    exit(
      claimRewards: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getReward(
      _rewardTokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getRewardForDuration(_rewardsToken: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    incentivesController(overrides?: CallOverrides): Promise<[string]>;

    lastTimeRewardApplicable(
      _rewardsToken: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    lockDuration(overrides?: CallOverrides): Promise<[BigNumber]>;

    lockedBalances(
      user: string,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        ([BigNumber, BigNumber] & {
          amount: BigNumber;
          unlockTime: BigNumber;
        })[]
      ] & {
        total: BigNumber;
        unlockable: BigNumber;
        locked: BigNumber;
        lockData: ([BigNumber, BigNumber] & {
          amount: BigNumber;
          unlockTime: BigNumber;
        })[];
      }
    >;

    lockedSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    mint(
      user: string,
      amount: BigNumberish,
      withPenalty: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    minters(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;

    mintersAreSet(overrides?: CallOverrides): Promise<[boolean]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    recoverERC20(
      tokenAddress: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    rewardData(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        periodFinish: BigNumber;
        rewardRate: BigNumber;
        lastUpdateTime: BigNumber;
        rewardPerTokenStored: BigNumber;
        balance: BigNumber;
      }
    >;

    rewardPerToken(_rewardsToken: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    rewardTokens(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    rewards(arg0: string, arg1: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    rewardsDuration(overrides?: CallOverrides): Promise<[BigNumber]>;

    setIncentivesController(
      _controller: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setMinters(
      _minters: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    stake(
      amount: BigNumberish,
      lock: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    stakingToken(overrides?: CallOverrides): Promise<[string]>;

    totalBalance(
      user: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    unlockedBalance(
      user: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    userRewardPerTokenPaid(
      arg0: string,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    withdrawExpiredLocks(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    withdrawableBalance(
      user: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { amount: BigNumber; penaltyAmount: BigNumber }>;
  };

  addReward(
    _rewardsToken: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  claimableRewards(
    account: string,
    overrides?: CallOverrides
  ): Promise<([string, BigNumber] & { token: string; amount: BigNumber })[]>;

  earnedBalances(
    user: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, ([BigNumber, BigNumber] & { amount: BigNumber; unlockTime: BigNumber })[]] & {
      total: BigNumber;
      earningsData: ([BigNumber, BigNumber] & {
        amount: BigNumber;
        unlockTime: BigNumber;
      })[];
    }
  >;

  exit(
    claimRewards: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getReward(
    _rewardTokens: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getRewardForDuration(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

  incentivesController(overrides?: CallOverrides): Promise<string>;

  lastTimeRewardApplicable(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

  lockDuration(overrides?: CallOverrides): Promise<BigNumber>;

  lockedBalances(
    user: string,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      ([BigNumber, BigNumber] & { amount: BigNumber; unlockTime: BigNumber })[]
    ] & {
      total: BigNumber;
      unlockable: BigNumber;
      locked: BigNumber;
      lockData: ([BigNumber, BigNumber] & {
        amount: BigNumber;
        unlockTime: BigNumber;
      })[];
    }
  >;

  lockedSupply(overrides?: CallOverrides): Promise<BigNumber>;

  mint(
    user: string,
    amount: BigNumberish,
    withPenalty: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  minters(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  mintersAreSet(overrides?: CallOverrides): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  recoverERC20(
    tokenAddress: string,
    tokenAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  rewardData(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      periodFinish: BigNumber;
      rewardRate: BigNumber;
      lastUpdateTime: BigNumber;
      rewardPerTokenStored: BigNumber;
      balance: BigNumber;
    }
  >;

  rewardPerToken(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

  rewardTokens(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  rewards(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

  rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;

  setIncentivesController(
    _controller: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setMinters(
    _minters: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  stake(
    amount: BigNumberish,
    lock: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  stakingToken(overrides?: CallOverrides): Promise<string>;

  totalBalance(user: string, overrides?: CallOverrides): Promise<BigNumber>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  unlockedBalance(user: string, overrides?: CallOverrides): Promise<BigNumber>;

  userRewardPerTokenPaid(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

  withdraw(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  withdrawExpiredLocks(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  withdrawableBalance(
    user: string,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber] & { amount: BigNumber; penaltyAmount: BigNumber }>;

  callStatic: {
    addReward(_rewardsToken: string, overrides?: CallOverrides): Promise<void>;

    claimableRewards(
      account: string,
      overrides?: CallOverrides
    ): Promise<([string, BigNumber] & { token: string; amount: BigNumber })[]>;

    earnedBalances(
      user: string,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        ([BigNumber, BigNumber] & {
          amount: BigNumber;
          unlockTime: BigNumber;
        })[]
      ] & {
        total: BigNumber;
        earningsData: ([BigNumber, BigNumber] & {
          amount: BigNumber;
          unlockTime: BigNumber;
        })[];
      }
    >;

    exit(claimRewards: boolean, overrides?: CallOverrides): Promise<void>;

    getReward(_rewardTokens: string[], overrides?: CallOverrides): Promise<void>;

    getRewardForDuration(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    incentivesController(overrides?: CallOverrides): Promise<string>;

    lastTimeRewardApplicable(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    lockDuration(overrides?: CallOverrides): Promise<BigNumber>;

    lockedBalances(
      user: string,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        ([BigNumber, BigNumber] & {
          amount: BigNumber;
          unlockTime: BigNumber;
        })[]
      ] & {
        total: BigNumber;
        unlockable: BigNumber;
        locked: BigNumber;
        lockData: ([BigNumber, BigNumber] & {
          amount: BigNumber;
          unlockTime: BigNumber;
        })[];
      }
    >;

    lockedSupply(overrides?: CallOverrides): Promise<BigNumber>;

    mint(
      user: string,
      amount: BigNumberish,
      withPenalty: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    minters(arg0: string, overrides?: CallOverrides): Promise<boolean>;

    mintersAreSet(overrides?: CallOverrides): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    recoverERC20(
      tokenAddress: string,
      tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    rewardData(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        periodFinish: BigNumber;
        rewardRate: BigNumber;
        lastUpdateTime: BigNumber;
        rewardPerTokenStored: BigNumber;
        balance: BigNumber;
      }
    >;

    rewardPerToken(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    rewardTokens(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    rewards(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

    rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;

    setIncentivesController(_controller: string, overrides?: CallOverrides): Promise<void>;

    setMinters(_minters: string[], overrides?: CallOverrides): Promise<void>;

    stake(amount: BigNumberish, lock: boolean, overrides?: CallOverrides): Promise<void>;

    stakingToken(overrides?: CallOverrides): Promise<string>;

    totalBalance(user: string, overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(newOwner: string, overrides?: CallOverrides): Promise<void>;

    unlockedBalance(user: string, overrides?: CallOverrides): Promise<BigNumber>;

    userRewardPerTokenPaid(
      arg0: string,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdraw(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    withdrawExpiredLocks(overrides?: CallOverrides): Promise<void>;

    withdrawableBalance(
      user: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { amount: BigNumber; penaltyAmount: BigNumber }>;
  };

  filters: {
    'OwnershipTransferred(address,address)'(
      previousOwner?: string | null,
      newOwner?: string | null
    ): TypedEventFilter<[string, string], { previousOwner: string; newOwner: string }>;

    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): TypedEventFilter<[string, string], { previousOwner: string; newOwner: string }>;

    'Recovered(address,uint256)'(
      token?: null,
      amount?: null
    ): TypedEventFilter<[string, BigNumber], { token: string; amount: BigNumber }>;

    Recovered(
      token?: null,
      amount?: null
    ): TypedEventFilter<[string, BigNumber], { token: string; amount: BigNumber }>;

    'RewardAdded(uint256)'(reward?: null): TypedEventFilter<[BigNumber], { reward: BigNumber }>;

    RewardAdded(reward?: null): TypedEventFilter<[BigNumber], { reward: BigNumber }>;

    'RewardPaid(address,address,uint256)'(
      user?: string | null,
      rewardsToken?: string | null,
      reward?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { user: string; rewardsToken: string; reward: BigNumber }
    >;

    RewardPaid(
      user?: string | null,
      rewardsToken?: string | null,
      reward?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { user: string; rewardsToken: string; reward: BigNumber }
    >;

    'RewardsDurationUpdated(address,uint256)'(
      token?: null,
      newDuration?: null
    ): TypedEventFilter<[string, BigNumber], { token: string; newDuration: BigNumber }>;

    RewardsDurationUpdated(
      token?: null,
      newDuration?: null
    ): TypedEventFilter<[string, BigNumber], { token: string; newDuration: BigNumber }>;

    'Staked(address,uint256,bool)'(
      user?: string | null,
      amount?: null,
      locked?: null
    ): TypedEventFilter<
      [string, BigNumber, boolean],
      { user: string; amount: BigNumber; locked: boolean }
    >;

    Staked(
      user?: string | null,
      amount?: null,
      locked?: null
    ): TypedEventFilter<
      [string, BigNumber, boolean],
      { user: string; amount: BigNumber; locked: boolean }
    >;

    'Withdrawn(address,uint256,uint256)'(
      user?: string | null,
      receivedAmount?: null,
      penaltyPaid?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { user: string; receivedAmount: BigNumber; penaltyPaid: BigNumber }
    >;

    Withdrawn(
      user?: string | null,
      receivedAmount?: null,
      penaltyPaid?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { user: string; receivedAmount: BigNumber; penaltyPaid: BigNumber }
    >;
  };

  estimateGas: {
    addReward(
      _rewardsToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    claimableRewards(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    earnedBalances(user: string, overrides?: CallOverrides): Promise<BigNumber>;

    exit(
      claimRewards: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getReward(
      _rewardTokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getRewardForDuration(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    incentivesController(overrides?: CallOverrides): Promise<BigNumber>;

    lastTimeRewardApplicable(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    lockDuration(overrides?: CallOverrides): Promise<BigNumber>;

    lockedBalances(user: string, overrides?: CallOverrides): Promise<BigNumber>;

    lockedSupply(overrides?: CallOverrides): Promise<BigNumber>;

    mint(
      user: string,
      amount: BigNumberish,
      withPenalty: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    minters(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    mintersAreSet(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    recoverERC20(
      tokenAddress: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    rewardData(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    rewardPerToken(_rewardsToken: string, overrides?: CallOverrides): Promise<BigNumber>;

    rewardTokens(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    rewards(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

    rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;

    setIncentivesController(
      _controller: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setMinters(
      _minters: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    stake(
      amount: BigNumberish,
      lock: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    stakingToken(overrides?: CallOverrides): Promise<BigNumber>;

    totalBalance(user: string, overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    unlockedBalance(user: string, overrides?: CallOverrides): Promise<BigNumber>;

    userRewardPerTokenPaid(
      arg0: string,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    withdrawExpiredLocks(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    withdrawableBalance(user: string, overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    addReward(
      _rewardsToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    claimableRewards(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    earnedBalances(user: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    exit(
      claimRewards: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getReward(
      _rewardTokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getRewardForDuration(
      _rewardsToken: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    incentivesController(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastTimeRewardApplicable(
      _rewardsToken: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lockDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockedBalances(user: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockedSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    mint(
      user: string,
      amount: BigNumberish,
      withPenalty: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    minters(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    mintersAreSet(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    recoverERC20(
      tokenAddress: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    rewardData(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardPerToken(_rewardsToken: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardTokens(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewards(arg0: string, arg1: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardsDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setIncentivesController(
      _controller: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setMinters(
      _minters: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    stake(
      amount: BigNumberish,
      lock: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    stakingToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalBalance(user: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    unlockedBalance(user: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    userRewardPerTokenPaid(
      arg0: string,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    withdrawExpiredLocks(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    withdrawableBalance(user: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
